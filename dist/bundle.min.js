(function (fetch) {
  'use strict';

  fetch = 'default' in fetch ? fetch['default'] : fetch;

  var __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;
  function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }


  var babelHelpers = {};
  babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers.toArray = function (arr) {
    return Array.isArray(arr) ? arr : Array.from(arr);
  };

  babelHelpers.toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  babelHelpers;

  /**
   * Tests whether a variable is a number, or a numeric string.
   *
   * @param {string|number} maybeStr The variable to test.
   * @returns {boolean} True if numeric.
   */
  function isNumeric(maybeStr) {
    if (Array.isArray(maybeStr)) {
      return false;
    }

    return Math.abs(maybeStr - parseFloat(maybeStr)) > -Number.EPSILON;
  }

  /**
   * Gets a random element from a collection such as an object, array, or string
   * (where it gets a single character).
   *
   * @param {object|Array|string|Range} collection Thing to get the element from.
   * @returns {*} Element from the collection.
   */
  function getRandomElementOf(collection) {
    if (typeof collection.getRandom === 'function') {
      return collection.getRandom();
    }

    if (collection.length) {
      return collection[Math.floor(Math.random() * collection.length)];
    }

    return collection[getRandomElementOf(Object.keys(collection))];
  }

  /**
   * A small utility function for use in generators: calls a transform function
   * on either the specified value, or the result of the specified promise. I was
   * writing this a lot, so I split it out.
   *
   * @param {Promise|*} resolved A value that might be a promise.
   * @param {function} fn Transform function. Not a callback.
   * @returns {Promise|*} Either the transformed function, or a new promise
   *                      adding the transform function to specified promise.
   */
  function getYieldValue(resolved, fn) {
    if (isThenable(resolved)) {
      return resolved.then(fn);
    }

    return fn(resolved);
  }

  /**
   * A minimal implementation of Object.assign(), which is not defined in node
   * 0.12.
   *
   * @param {object} target The element to copy properties to.
   * @param {...object} sources One or more objects to copy to the target.
   * @returns {object} Merged objects.
   */
  function objectAssign(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var source = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = Object.keys(source)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;

            target[key] = source[key];
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return target;
  }

  /**
   * Detects whether a given value is a promise or promise-like object.
   *
   * @param {*} value The value to check.
   * @returns {boolean} True if "thenable".
   */
  function isThenable(value) {
    return typeof value.then === 'function';
  }

  /**
   * A container for a range of numbers or characters with a few helpful
   * functions.
   *
   * @param {string} input The range, eg "1-10" or "D-T".
   * @constructor
   */
  function Range(input) {
  	input = /(-?[^-]+)-(-?[^-]+)/.exec(input);

  	if (isNumeric(input[1]) && isNumeric(input[2])) {
  		this.type = 'number';

  		this.min = Number(input[1]);
  		this.max = Number(input[2]);
  	} else {
  		this.type = 'char';

  		this.min = input[1];
  		this.max = input[2];

  		this._minCharCode = this.min.charCodeAt(0);
  		this._maxCharCode = this.max.charCodeAt(0);
  	}
  }

  /**
   * Tests whether a given number or character is within the range.
   *
   * @param {string|number} num The number or character to test.
   * @returns {boolean} True if within the range.
   */
  Range.prototype.isInRange = function (num) {
  	return num <= this.max && num >= this.min;
  };

  /**
   * Gets a random character or number within the range.
   *
   * @returns {string|number} A random char or number.
   */
  Range.prototype.getRandom = function () {
  	if (this.type === 'number') {
  		return (this.max - this.min) * Math.random() + this.min;
  	}

  	if (this.type === 'char') {
  		var min = this._minCharCode;
  		var max = this._maxCharCode;

  		return String.fromCharCode((max - min) * Math.random() + min);
  	}
  };

  /**
   * Gets a random integer within the range.
   *
   * @returns {number} A random integer.
   */
  Range.prototype.getRandomInt = function () {
  	return Math.floor((this.max + 1 - this.min) * Math.random() + this.min);
  };

  var runtime = __commonjs(function (module, exports, global) {
    /**
     * Copyright (c) 2014, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
     * additional grant of patent rights can be found in the PATENTS file in
     * the same directory.
     */

    !function (global) {
      "use strict";

      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined; // More compressible than void 0.
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      var inModule = (typeof module === "undefined" ? "undefined" : babelHelpers.typeof(module)) === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          // If regeneratorRuntime is defined globally and we're in a module,
          // make the exports object identical to regeneratorRuntime.
          module.exports = runtime;
        }
        // Don't bother evaluating the rest of this file if the runtime was
        // already defined globally.
        return;
      }

      // Define the runtime globally (as expected by generated code) as either
      // module.exports (if we're in a module) or a new, empty object.
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided, then outerFn.prototype instanceof Generator.
        var generator = Object.create((outerFn || Generator).prototype);
        var context = new Context(tryLocsList || []);

        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        generator._invoke = makeInvokeMethod(innerFn, self, context);

        return generator;
      }
      runtime.wrap = wrap;

      // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";

      // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.
      var ContinueSentinel = {};

      // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

      // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      runtime.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      runtime.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `value instanceof AwaitArgument` to determine if the yielded value is
      // meant to be awaited. Some may consider the name of this method too
      // cutesy, but they are curmudgeons.
      runtime.awrap = function (arg) {
        return new AwaitArgument(arg);
      };

      function AwaitArgument(arg) {
        this.arg = arg;
      }

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value instanceof AwaitArgument) {
              return Promise.resolve(value.arg).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return Promise.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration. If the Promise is rejected, however, the
              // result for this iteration will be rejected with the same
              // reason. Note that rejections of yielded Promises are not
              // thrown back into the generator function, as is the case
              // when an awaited Promise is rejected. This difference in
              // behavior between yield and await is important, because it
              // allows the consumer to decide what to do with the yielded
              // rejection (swallow it and continue, manually .throw it back
              // into the generator, abandon iteration, whatever). With
              // await, by contrast, there is no opportunity to examine the
              // rejection reason outside the generator function, so the
              // only option is to throw it from the await expression, and
              // let the generator function handle the exception.
              result.value = unwrapped;
              resolve(result);
            }, reject);
          }
        }

        if ((typeof process === "undefined" ? "undefined" : babelHelpers.typeof(process)) === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }

        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.
      runtime.async = function (innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;

        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }

            // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            return doneResult();
          }

          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                // A return or throw (when the delegate iterator has no throw
                // method) always terminates the yield* loop.
                context.delegate = null;

                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    // If the return method threw an exception, let that
                    // exception prevail over the original return or throw.
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }

                if (method === "return") {
                  // Continue with the outer return, now that the delegate
                  // iterator has been terminated.
                  continue;
                }
              }

              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

              if (record.type === "throw") {
                context.delegate = null;

                // Like returning generator.throw(uncaught), but without the
                // overhead of an extra function call.
                method = "throw";
                arg = record.arg;
                continue;
              }

              // Delegate generator ran and handled its own exceptions so
              // regardless of what the method was, we continue as if it is
              // "next" with an undefined arg.
              method = "next";
              arg = undefined;

              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }

              context.delegate = null;
            }

            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }

              if (context.dispatchException(arg)) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }

            state = GenStateExecuting;

            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              var info = {
                value: record.arg,
                done: context.done
              };

              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  // Deliberately forget the last sent value so that we don't
                  // accidentally pass it on to the delegate.
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              // Dispatch the exception by looping back around to the
              // context.dispatchException(arg) call above.
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }

      // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.
      defineIteratorMethods(Gp);

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp[toStringTagSymbol] = "Generator";

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      runtime.keys = function (object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();

        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.
          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined;
              next.done = true;

              return next;
            };

            return next.next = next;
          }
        }

        // Return an iterator with no values.
        return { next: doneResult };
      }
      runtime.values = values;

      function doneResult() {
        return { value: undefined, done: true };
      }

      Context.prototype = {
        constructor: Context,

        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;

          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },

        stop: function stop() {
          this.done = true;

          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },

        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },

        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }

          return ContinueSentinel;
        },

        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },

        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },

        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }

          // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.
          throw new Error("illegal catch attempt");
        },

        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          return ContinueSentinel;
        }
      };
    }(
    // Among the various tricks for obtaining a reference to the global
    // object, this seems to be the most reliable technique that does not
    // use indirect eval (which violates Content Security Policy).
    (typeof global === "undefined" ? "undefined" : babelHelpers.typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === "object" ? self : __commonjs_global);
  });

  var require$$0 = runtime && (typeof runtime === "undefined" ? "undefined" : babelHelpers.typeof(runtime)) === 'object' && 'default' in runtime ? runtime['default'] : runtime;

  var runtimeModule = __commonjs(function (module, exports, global) {
    // This method of obtaining a reference to the global object needs to be
    // kept identical to the way it is obtained in runtime.js
    var g = (typeof global === "undefined" ? "undefined" : babelHelpers.typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === "object" ? self : __commonjs_global;

    // Use `getOwnPropertyNames` because not all browsers support calling
    // `hasOwnProperty` on the global `self` object in a worker. See #183.
    var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

    // Save the old regeneratorRuntime in case it needs to be restored later.
    var oldRuntime = hadRuntime && g.regeneratorRuntime;

    // Force reevalutation of runtime.js.
    g.regeneratorRuntime = undefined;

    module.exports = require$$0;

    if (hadRuntime) {
      // Restore the original runtime.
      g.regeneratorRuntime = oldRuntime;
    } else {
      // Remove the global property added by runtime.js.
      try {
        delete g.regeneratorRuntime;
      } catch (e) {
        g.regeneratorRuntime = undefined;
      }
    }
  });

  var regeneratorRuntime = runtimeModule && (typeof runtimeModule === "undefined" ? "undefined" : babelHelpers.typeof(runtimeModule)) === 'object' && 'default' in runtimeModule ? runtimeModule['default'] : runtimeModule;

  var generators = {};
  /**
   * Returns a string of random length, or calls another generator and converts
   * the results into a string.
   *
   * @param {object} options Configuration.
   * @param {string} range Either a range determining the length of the generated
   *                       string, or a string to generator another generator.
   */
  generators.string = regeneratorRuntime.mark(function _callee(options) {
  	var range = arguments.length <= 1 || arguments[1] === undefined ? '10-20' : arguments[1];
  	var length, str, i, generator, toString, resolved;
  	return regeneratorRuntime.wrap(function _callee$(_context) {
  		while (1) {
  			switch (_context.prev = _context.next) {
  				case 0:
  					if (!/^\d+-\d+$/.test(range)) {
  						_context.next = 12;
  						break;
  					}

  					range = new Range(range);

  				case 2:
  					if (!true) {}

  					length = range.getRandomInt();
  					str = '';


  					for (i = 0; i < length; i++) {
  						str += getRandomElementOf(options.letters);
  					}

  					_context.next = 8;
  					return str;

  				case 8:
  					_context.next = 2;
  					break;

  				case 10:
  					_context.next = 20;
  					break;

  				case 12:
  					generator = new Generator(range);

  					toString = function toString(val) {
  						return val.toString();
  					};

  				case 14:
  					if (!true) {}

  					resolved = generator.resolve();
  					_context.next = 18;
  					return getYieldValue(resolved, toString);

  				case 18:
  					_context.next = 14;
  					break;

  				case 20:
  				case 'end':
  					return _context.stop();
  			}
  		}
  	}, _callee, this);
  });

  /**
   * Returns a number between in a given range of numbers, of a given precision.
   *
   * @param {object} options Configuration.
   * @param {string} range A range to generate numbers from.
   * @param {number} precision A precision to round the generated number to.
   */
  generators.number = regeneratorRuntime.mark(function _callee2(options) {
  	var range = arguments.length <= 1 || arguments[1] === undefined ? '0-1' : arguments[1];
  	var precision = arguments[2];
  	var decimals, random;
  	return regeneratorRuntime.wrap(function _callee2$(_context2) {
  		while (1) {
  			switch (_context2.prev = _context2.next) {
  				case 0:
  					range = new Range(range);

  					if (isNumeric(precision)) {
  						_context2.next = 9;
  						break;
  					}

  				case 2:
  					if (!true) {}

  					_context2.next = 5;
  					return range.getRandom();

  				case 5:
  					_context2.next = 2;
  					break;

  				case 7:
  					_context2.next = 21;
  					break;

  				case 9:
  					decimals = -Math.round(Math.log10(precision));

  				case 10:
  					if (!true) {}

  					random = range.getRandom();

  					if (!(precision < 1)) {
  						_context2.next = 17;
  						break;
  					}

  					_context2.next = 15;
  					return Number(random.toFixed(decimals));

  				case 15:
  					_context2.next = 19;
  					break;

  				case 17:
  					_context2.next = 19;
  					return Math.round(random / precision) * precision;

  				case 19:
  					_context2.next = 10;
  					break;

  				case 21:
  				case 'end':
  					return _context2.stop();
  			}
  		}
  	}, _callee2, this);
  });

  /**
   * Returns an integer in a given range of numbers.
   * @param {object} options Configuration.
   * @param {string} range A range to generate integers from.
   */
  generators.int = regeneratorRuntime.mark(function _callee3(options) {
  	var range = arguments.length <= 1 || arguments[1] === undefined ? '0-10' : arguments[1];
  	return regeneratorRuntime.wrap(function _callee3$(_context3) {
  		while (1) {
  			switch (_context3.prev = _context3.next) {
  				case 0:
  					range = new Range(range);

  				case 1:
  					if (!true) {}

  					_context3.next = 4;
  					return range.getRandomInt();

  				case 4:
  					_context3.next = 1;
  					break;

  				case 6:
  				case 'end':
  					return _context3.stop();
  			}
  		}
  	}, _callee3, this);
  });

  /**
   * Returns a character in a given range of characters.
   *
   * @param {object} options Configuration.
   * @param range
   */
  generators.char = regeneratorRuntime.mark(function _callee4(options) {
  	var range = arguments.length <= 1 || arguments[1] === undefined ? 'A-Z' : arguments[1];
  	return regeneratorRuntime.wrap(function _callee4$(_context4) {
  		while (1) {
  			switch (_context4.prev = _context4.next) {
  				case 0:
  					range = new Range(range);

  				case 1:
  					if (!true) {}

  					_context4.next = 4;
  					return range.getRandom();

  				case 4:
  					_context4.next = 1;
  					break;

  				case 6:
  				case 'end':
  					return _context4.stop();
  			}
  		}
  	}, _callee4, this);
  });

  /**
   * Returns true or false, with a given bias.
   *
   * @param {object} options Configuration.
   * @param {number} bias Number between 0 and 1: the higher to 1, the greater
   *                      the chance of true.
   */
  generators.boolean = regeneratorRuntime.mark(function _callee5(options) {
  	var bias = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];
  	return regeneratorRuntime.wrap(function _callee5$(_context5) {
  		while (1) {
  			switch (_context5.prev = _context5.next) {
  				case 0:
  					if (!true) {}

  					_context5.next = 3;
  					return Math.random() < bias;

  				case 3:
  					_context5.next = 0;
  					break;

  				case 5:
  				case 'end':
  					return _context5.stop();
  			}
  		}
  	}, _callee5, this);
  });

  /**
   * Returns one of a given number of generators.
   *
   * @param {object} options Configuration.
   * @param {...string} generatorStrings A number of generators to choose from.
   */
  generators.oneOf = regeneratorRuntime.mark(function _callee6(options) {
  	for (var _len = arguments.length, generatorStrings = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		generatorStrings[_key - 1] = arguments[_key];
  	}

  	var generators, _generator;

  	return regeneratorRuntime.wrap(function _callee6$(_context6) {
  		while (1) {
  			switch (_context6.prev = _context6.next) {
  				case 0:
  					generators = generatorStrings.map(function (str) {
  						return new Generator(str);
  					});

  				case 1:
  					if (!true) {}

  					_generator = getRandomElementOf(generators);
  					_context6.next = 5;
  					return _generator.resolve();

  				case 5:
  					_context6.next = 1;
  					break;

  				case 7:
  				case 'end':
  					return _context6.stop();
  			}
  		}
  	}, _callee6, this);
  });

  /**
   * Returns an array generated from given generators.
   * @param {object} options Configuration.
   * @param {...string} generatorsStrings A number of generators.
   */
  generators.array = regeneratorRuntime.mark(function _callee7(options) {
  	for (var _len2 = arguments.length, generatorsStrings = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
  		generatorsStrings[_key2 - 1] = arguments[_key2];
  	}

  	var generators, resolveGenerator, all;
  	return regeneratorRuntime.wrap(function _callee7$(_context7) {
  		while (1) {
  			switch (_context7.prev = _context7.next) {
  				case 0:
  					generators = generatorsStrings.map(function (str) {
  						return new Generator(str);
  					});

  					resolveGenerator = function resolveGenerator(generator) {
  						return generator.resolve();
  					};

  				case 2:
  					if (!true) {}

  					all = generators.map(resolveGenerator);

  					// Promise.all will resolve immediately if none of the values are promises

  					_context7.next = 6;
  					return Promise.all(all);

  				case 6:
  					_context7.next = 2;
  					break;

  				case 8:
  				case 'end':
  					return _context7.stop();
  			}
  		}
  	}, _callee7, this);
  });

  /**
   * Repeats a given generator a number of times.
   *
   * @param {object} options Configuration.
   * @param {number} n The number of times to repeat the generator.
   * @param {string} generatorString A generator as a string.
   */
  generators.repeat = regeneratorRuntime.mark(function _callee8(options, n, generatorString) {
  	var generator, joinValues, ary, _i;

  	return regeneratorRuntime.wrap(function _callee8$(_context8) {
  		while (1) {
  			switch (_context8.prev = _context8.next) {
  				case 0:
  					generator = new Generator(generatorString);

  					joinValues = function joinValues(values) {
  						return values.join('');
  					};

  				case 2:
  					if (!true) {}

  					ary = [];

  					for (_i = 0; _i < n; _i++) {
  						ary.push(generator.resolve());
  					}

  					_context8.next = 7;
  					return Promise.all(ary).then(joinValues);

  				case 7:
  					_context8.next = 2;
  					break;

  				case 9:
  				case 'end':
  					return _context8.stop();
  			}
  		}
  	}, _callee8, this);
  });

  /**
   * Returns a value specified as JSON.
   *
   * @param {object} options Configuration.
   * @param {string} json The value to return as JSON.
   */
  generators.literal = regeneratorRuntime.mark(function _callee9(options, json) {
  	var returnValue;
  	return regeneratorRuntime.wrap(function _callee9$(_context9) {
  		while (1) {
  			switch (_context9.prev = _context9.next) {
  				case 0:
  					returnValue = JSON.parse(json);

  				case 1:
  					if (!true) {}

  					_context9.next = 4;
  					return returnValue;

  				case 4:
  					_context9.next = 1;
  					break;

  				case 6:
  				case 'end':
  					return _context9.stop();
  			}
  		}
  	}, _callee9, this);
  });

  /**
   * Gets an entry from an object or array, specified in the options.
   *
   * @param {object} options Configuration.
   * @param {string} [prop="collection"] The property of the options to look at.
   */
  generators.entry = regeneratorRuntime.mark(function _callee10(options) {
  	var prop = arguments.length <= 1 || arguments[1] === undefined ? 'collection' : arguments[1];
  	var collection;
  	return regeneratorRuntime.wrap(function _callee10$(_context10) {
  		while (1) {
  			switch (_context10.prev = _context10.next) {
  				case 0:
  					collection = options[prop];

  					if (collection) {
  						_context10.next = 3;
  						break;
  					}

  					throw new Error('Collection ' + prop + ' not found');

  				case 3:
  					if (!true) {}

  					_context10.next = 6;
  					return getRandomElementOf(collection);

  				case 6:
  					_context10.next = 3;
  					break;

  				case 8:
  				case 'end':
  					return _context10.stop();
  			}
  		}
  	}, _callee10, this);
  });

  /**
   * Create an object with a resolve method that can be called to generate
   * random values from a given generator.
   *
   * @param {string} generatorString The string to be parsed to create the
   *                                 generator.
   * @param {object} [opts] Options. Configuration. Stuff.
   * @constructor
   */
  function Generator(generatorString, opts) {
  	var match = undefined;

  	// Deal with 12*(generator)
  	if (match = /^(\d+)\*(\(.+\))$/.exec(generatorString)) {
  		return new Generator('repeat:' + match[1] + ':' + match[2], opts);
  	}

  	// Deal with 1-10
  	if (match = /^-?[\d.]+--?[\d.]+$/.exec(generatorString)) {
  		return new Generator('number:' + match[0]);
  	}

  	// Deal with A-Z
  	if (match = /^[a-z]-[a-z]$/i.exec(generatorString)) {
  		return new Generator('char:' + match[0]);
  	}

  	// Deal with "strings"
  	if (match = /^".+"$/.exec(generatorString)) {
  		return new Generator('literal:' + match[0]);
  	}

  	var _splitString = splitString(generatorString);

  	var _splitString2 = babelHelpers.toArray(_splitString);

  	var type = _splitString2[0];

  	var args = _splitString2.slice(1);

  	this._type = type;
  	this._args = args;

  	if (!generators[type]) {
  		throw new Error('Generator "' + type + '" not found');
  	}

  	var generator = generators[type].apply(generators, [opts].concat(babelHelpers.toConsumableArray(args)));

  	// We call the generator early to see if it returns a promise or not.
  	var firstValue = generator.next().value;
  	this.async = isThenable(firstValue);

  	this.resolve = function (cb) {
  		// We don't want to throw away the result of the early call.
  		var value = firstValue || generator.next().value;
  		firstValue = null;

  		if (typeof cb === 'function') {
  			if (isThenable(value)) {
  				value.then(cb);
  			} else {
  				cb(value);
  			}
  		}

  		return value;
  	};
  }

  function splitString(generatorString) {
  	var splitString = [''];
  	var inBrackets = false;

  	for (var i = 0; i < generatorString.length; i++) {
  		if (generatorString[i] === '(') {
  			inBrackets = true;
  		} else if (generatorString[i] === ')') {
  			inBrackets = false;
  		} else if (generatorString[i] === ':' && !inBrackets) {
  			splitString.push('');
  		} else {
  			splitString[splitString.length - 1] += generatorString[i];
  		}
  	}

  	return splitString;
  }

  /**
   * Takes a given generator and calls a function a number of times with some
   * random strings or something.
   *
   * @param {...string} generatorStrings Strings to create generators from.
   * @param {object} [opts] Optional options, such as number of iterations.
   * @param {function} fn The function to call.
   * @returns {Promise} A promise that resolves when all callbacks are called.
   */
  function deity() {
  	var strings = [];
  	var opts = objectAssign({}, deity.defaultOptions);
  	var fn = undefined;

  	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  		args[_key] = arguments[_key];
  	}

  	args.forEach(function (arg) {
  		if (typeof arg === 'string') {
  			strings.push(arg);
  		} else if ((typeof arg === 'undefined' ? 'undefined' : babelHelpers.typeof(arg)) === 'object') {
  			objectAssign(opts, arg);
  		} else if (typeof arg === 'function') {
  			fn = arg;
  		}
  	});

  	if (strings.length === 0) {
  		throw new TypeError('NO_GENERATOR: You must specify at least one generator for Deity');
  	}

  	if (typeof fn !== 'function') {
  		throw new TypeError('NO_CALLBACK: You must specify a callback function for Deity');
  	}

  	var generators = strings.map(function (string) {
  		return new Generator(string, opts);
  	});
  	var allSync = generators.every(function (generator) {
  		return !generator.async;
  	});

  	var promiseArray = [];

  	// Function for inside the async loop
  	var generatorToPromise = function generatorToPromise(generator) {
  		return new Promise(function (resolve) {
  			return generator.resolve(resolve);
  		});
  	};

  	for (var i = 0; i < opts.iterations; i++) {
  		var maybePromise = undefined;

  		if (allSync) {
  			// Case one: all specified generators are synchronous. We don't need to mess
  			// about with promises. This is simple.
  			var vals = generators.map(function (generator) {
  				return generator.resolve();
  			});
  			// We allow any thrown errors to be thrown: no need to wrap in Promise
  			maybePromise = fn.apply(undefined, babelHelpers.toConsumableArray(vals));
  		} else {
  			// Case two: one or more generators are asynchronous. We use promises to
  			// make sure that nothing is called early and to handle errors.

  			// We can't call the callback until _all_ the generators have returned
  			maybePromise = Promise.all(generators.map(generatorToPromise)).then(function (values) {
  				return fn.apply(undefined, babelHelpers.toConsumableArray(values));
  			});
  		}

  		promiseArray.push(maybePromise);
  	}

  	return Promise.all(promiseArray);
  }

  /**
   * Add a new generator or generators. Accepts either a single named a function,
   * a name and a function, or an object containing keys as names and functions.
   *
   * @param {string|object} [key] The name of the generator, or an object of
   *                              multiple generators.
   * @param {function} fn A generator function. If named, key is optional.
   */
  deity.extend = function (key, fn) {
  	if (typeof key === 'function' && key.name) {
  		generators[key.name] = key;
  	} else if ((typeof key === 'undefined' ? 'undefined' : babelHelpers.typeof(key)) === 'object') {
  		var _iteratorNormalCompletion = true;
  		var _didIteratorError = false;
  		var _iteratorError = undefined;

  		try {
  			for (var _iterator = Object.keys(key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
  				var pluginName = _step.value;

  				generators[pluginName] = key[pluginName];
  			}
  		} catch (err) {
  			_didIteratorError = true;
  			_iteratorError = err;
  		} finally {
  			try {
  				if (!_iteratorNormalCompletion && _iterator.return) {
  					_iterator.return();
  				}
  			} finally {
  				if (_didIteratorError) {
  					throw _iteratorError;
  				}
  			}
  		}
  	} else {
  		generators[key] = fn;
  	}
  };

  // Default configuration, merged with opts in the deity function.
  deity.defaultOptions = {
  	iterations: 100,
  	//letters: '1234567890ABCdefghjKLMNOpQRs',
  	letters: new Range('A-Z')
  };

  var runtime$1 = __commonjs(function (module, exports, global) {
    /**
     * Copyright (c) 2014, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
     * additional grant of patent rights can be found in the PATENTS file in
     * the same directory.
     */

    !function (global) {
      "use strict";

      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined; // More compressible than void 0.
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      var inModule = (typeof module === "undefined" ? "undefined" : babelHelpers.typeof(module)) === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          // If regeneratorRuntime is defined globally and we're in a module,
          // make the exports object identical to regeneratorRuntime.
          module.exports = runtime;
        }
        // Don't bother evaluating the rest of this file if the runtime was
        // already defined globally.
        return;
      }

      // Define the runtime globally (as expected by generated code) as either
      // module.exports (if we're in a module) or a new, empty object.
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided, then outerFn.prototype instanceof Generator.
        var generator = Object.create((outerFn || Generator).prototype);
        var context = new Context(tryLocsList || []);

        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        generator._invoke = makeInvokeMethod(innerFn, self, context);

        return generator;
      }
      runtime.wrap = wrap;

      // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";

      // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.
      var ContinueSentinel = {};

      // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

      // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      runtime.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      runtime.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `value instanceof AwaitArgument` to determine if the yielded value is
      // meant to be awaited. Some may consider the name of this method too
      // cutesy, but they are curmudgeons.
      runtime.awrap = function (arg) {
        return new AwaitArgument(arg);
      };

      function AwaitArgument(arg) {
        this.arg = arg;
      }

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value instanceof AwaitArgument) {
              return Promise.resolve(value.arg).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return Promise.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration. If the Promise is rejected, however, the
              // result for this iteration will be rejected with the same
              // reason. Note that rejections of yielded Promises are not
              // thrown back into the generator function, as is the case
              // when an awaited Promise is rejected. This difference in
              // behavior between yield and await is important, because it
              // allows the consumer to decide what to do with the yielded
              // rejection (swallow it and continue, manually .throw it back
              // into the generator, abandon iteration, whatever). With
              // await, by contrast, there is no opportunity to examine the
              // rejection reason outside the generator function, so the
              // only option is to throw it from the await expression, and
              // let the generator function handle the exception.
              result.value = unwrapped;
              resolve(result);
            }, reject);
          }
        }

        if ((typeof process === "undefined" ? "undefined" : babelHelpers.typeof(process)) === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }

        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.
      runtime.async = function (innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;

        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }

            // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            return doneResult();
          }

          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                // A return or throw (when the delegate iterator has no throw
                // method) always terminates the yield* loop.
                context.delegate = null;

                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    // If the return method threw an exception, let that
                    // exception prevail over the original return or throw.
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }

                if (method === "return") {
                  // Continue with the outer return, now that the delegate
                  // iterator has been terminated.
                  continue;
                }
              }

              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

              if (record.type === "throw") {
                context.delegate = null;

                // Like returning generator.throw(uncaught), but without the
                // overhead of an extra function call.
                method = "throw";
                arg = record.arg;
                continue;
              }

              // Delegate generator ran and handled its own exceptions so
              // regardless of what the method was, we continue as if it is
              // "next" with an undefined arg.
              method = "next";
              arg = undefined;

              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }

              context.delegate = null;
            }

            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }

              if (context.dispatchException(arg)) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }

            state = GenStateExecuting;

            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              var info = {
                value: record.arg,
                done: context.done
              };

              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  // Deliberately forget the last sent value so that we don't
                  // accidentally pass it on to the delegate.
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              // Dispatch the exception by looping back around to the
              // context.dispatchException(arg) call above.
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }

      // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.
      defineIteratorMethods(Gp);

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp[toStringTagSymbol] = "Generator";

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      runtime.keys = function (object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();

        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.
          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined;
              next.done = true;

              return next;
            };

            return next.next = next;
          }
        }

        // Return an iterator with no values.
        return { next: doneResult };
      }
      runtime.values = values;

      function doneResult() {
        return { value: undefined, done: true };
      }

      Context.prototype = {
        constructor: Context,

        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;

          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },

        stop: function stop() {
          this.done = true;

          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },

        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },

        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }

          return ContinueSentinel;
        },

        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },

        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },

        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }

          // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.
          throw new Error("illegal catch attempt");
        },

        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          return ContinueSentinel;
        }
      };
    }(
    // Among the various tricks for obtaining a reference to the global
    // object, this seems to be the most reliable technique that does not
    // use indirect eval (which violates Content Security Policy).
    (typeof global === "undefined" ? "undefined" : babelHelpers.typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === "object" ? self : __commonjs_global);
  });

  var require$$0$1 = runtime$1 && (typeof runtime$1 === "undefined" ? "undefined" : babelHelpers.typeof(runtime$1)) === 'object' && 'default' in runtime$1 ? runtime$1['default'] : runtime$1;

  var runtimeModule$1 = __commonjs(function (module, exports, global) {
    // This method of obtaining a reference to the global object needs to be
    // kept identical to the way it is obtained in runtime.js
    var g = (typeof global === "undefined" ? "undefined" : babelHelpers.typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === "object" ? self : __commonjs_global;

    // Use `getOwnPropertyNames` because not all browsers support calling
    // `hasOwnProperty` on the global `self` object in a worker. See #183.
    var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

    // Save the old regeneratorRuntime in case it needs to be restored later.
    var oldRuntime = hadRuntime && g.regeneratorRuntime;

    // Force reevalutation of runtime.js.
    g.regeneratorRuntime = undefined;

    module.exports = require$$0$1;

    if (hadRuntime) {
      // Restore the original runtime.
      g.regeneratorRuntime = oldRuntime;
    } else {
      // Remove the global property added by runtime.js.
      try {
        delete g.regeneratorRuntime;
      } catch (e) {
        g.regeneratorRuntime = undefined;
      }
    }
  });

  var regeneratorRuntime$1 = runtimeModule$1 && (typeof runtimeModule$1 === "undefined" ? "undefined" : babelHelpers.typeof(runtimeModule$1)) === 'object' && 'default' in runtimeModule$1 ? runtimeModule$1['default'] : runtimeModule$1;

  var _marked = [randomuser].map(regeneratorRuntime$1.mark);

  function randomuser(options) {
  	var url, userPromise;
  	return regeneratorRuntime$1.wrap(function randomuser$(_context) {
  		while (1) {
  			switch (_context.prev = _context.next) {
  				case 0:
  					url = 'https://randomuser.me/api/?results=' + options.iterations;
  					userPromise = fetch(url).then(function (res) {
  						return res.json();
  					});

  				case 2:
  					if (!true) {}

  					_context.next = 5;
  					return userPromise.then(function (data) {
  						// This function has side effects: it destroys the original data
  						var user = data.results.shift();

  						if (typeof user === 'undefined') {
  							throw new Error('No more users');
  						}

  						return user.user;
  					});

  				case 5:
  					_context.next = 2;
  					break;

  				case 7:
  				case 'end':
  					return _context.stop();
  			}
  		}
  	}, _marked[0], this);
  }

  deity.extend(randomuser);

  // Globally exposed so available in DevTools
  window.deity = deity;

  var ul = document.getElementById('output');

  function pushNew(text) {
  	var code = document.createElement('code');
  	code.textContent = text;

  	var li = document.createElement('li');
  	li.insertBefore(code, null);

  	ul.insertBefore(li, ul.firstChild);
  }

  function pushDivider() {
  	var li = document.createElement('li');
  	li.setAttribute('class', 'divider');

  	ul.insertBefore(li, ul.firstChild);
  }

  var form = document.getElementById('deity-form');
  var input = document.querySelector('[name="generator-string"]');

  form.addEventListener('submit', function (e) {
  	e.preventDefault();

  	deity(input.value, { iterations: 10 }, function (val) {
  		return pushNew(JSON.stringify(val));
  	}).then(function () {
  		return pushDivider();
  	});
  });

}(fetch));
//# sourceMappingURL=bundle.min.js.map